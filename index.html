<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultimate Snake Evolution</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }

    .game-container {
      background: rgba(0, 0, 0, 0.9);
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      position: relative;
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 0 10px;
    }

    .stats {
      display: flex;
      gap: 30px;
      font-size: 18px;
      font-weight: bold;
    }

    .stat-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .stat-icon {
      width: 24px;
      height: 24px;
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    canvas {
      background: #111;
      border: 3px solid #444;
      border-radius: 10px;
      display: block;
      image-rendering: pixelated;
    }

    .controls {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      gap: 20px;
    }

    button {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .menu-content {
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      border-radius: 20px;
      padding: 40px;
      max-width: 600px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      text-align: center;
    }

    .menu-title {
      font-size: 48px;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
    }

    .menu-subtitle {
      font-size: 18px;
      color: #aaa;
      margin-bottom: 30px;
    }

    .game-modes {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin-bottom: 30px;
    }

    .mode-btn {
      background: linear-gradient(135deg, #36d1dc, #5b86e5);
      padding: 20px;
      border-radius: 15px;
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
    }

    .mode-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 10px 30px rgba(54, 209, 220, 0.5);
    }

    .mode-name {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .mode-desc {
      font-size: 14px;
      opacity: 0.9;
    }

    .customization {
      margin: 30px 0;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
    }

    .custom-option {
      background: rgba(255, 255, 255, 0.1);
      padding: 10px;
      border-radius: 10px;
    }

    .custom-option label {
      display: block;
      margin-bottom: 5px;
      font-size: 14px;
    }

    select, input {
      width: 100%;
      padding: 8px;
      border-radius: 5px;
      border: none;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      font-size: 14px;
    }

    .achievements {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 300px;
      z-index: 500;
    }

    .achievement-popup {
      background: linear-gradient(135deg, #ffd700, #ffed4e);
      color: #333;
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 10px;
      animation: slideInRight 0.5s, fadeOut 0.5s 3s forwards;
      box-shadow: 0 5px 20px rgba(255, 215, 0, 0.5);
    }

    @keyframes slideInRight {
      from { transform: translateX(350px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    @keyframes fadeOut {
      to { opacity: 0; transform: translateY(-20px); }
    }

    .power-up-indicator {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #ff6b6b, #ffd93d);
      padding: 10px 20px;
      border-radius: 20px;
      font-weight: bold;
      animation: pulse 0.5s infinite;
      z-index: 100;
    }

    @keyframes pulse {
      0%, 100% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.05); }
    }

    .particle {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
      animation: particle-float 1s ease-out forwards;
    }

    @keyframes particle-float {
      to {
        transform: translateY(-50px) scale(0);
        opacity: 0;
      }
    }

    .hidden { display: none; }

    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      gap: 10px;
      z-index: 100;
    }

    .mobile-btn {
      width: 60px;
      height: 60px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    @media (max-width: 768px) {
      .mobile-controls { display: grid; grid-template-columns: repeat(3, 1fr); }
      .game-modes { grid-template-columns: 1fr; }
      .customization { grid-template-columns: 1fr; }
    }

    .combo-display {
      position: absolute;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
      animation: comboAnim 0.5s ease-out;
    }

    @keyframes comboAnim {
      0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
      50% { transform: translateX(-50%) scale(1.2); }
      100% { transform: translateX(-50%) scale(1); opacity: 1; }
    }
  </style>
</head>
<body>
  <!-- Main Menu -->
  <div id="mainMenu" class="menu-overlay">
    <div class="menu-content">
      <h1 class="menu-title">üêç SNAKE EVOLUTION</h1>
      <p class="menu-subtitle">The Ultimate Snake Experience</p>
      
      <div class="game-modes">
        <button class="mode-btn" data-mode="classic">
          <div class="mode-name">üéÆ Classic</div>
          <div class="mode-desc">Traditional snake gameplay</div>
        </button>
        <button class="mode-btn" data-mode="arcade">
          <div class="mode-name">üöÄ Arcade</div>
          <div class="mode-desc">Power-ups & special items</div>
        </button>
        <button class="mode-btn" data-mode="survival">
          <div class="mode-name">üíÄ Survival</div>
          <div class="mode-desc">How long can you survive?</div>
        </button>
        <button class="mode-btn" data-mode="challenge">
          <div class="mode-name">üèÜ Challenge</div>
          <div class="mode-desc">Complete specific objectives</div>
        </button>
      </div>

      <div class="customization">
        <div class="custom-option">
          <label>Snake Theme</label>
          <select id="themeSelect">
            <option value="neon">Neon</option>
            <option value="classic">Classic</option>
            <option value="rainbow">Rainbow</option>
            <option value="fire">Fire</option>
            <option value="ice">Ice</option>
            <option value="matrix">Matrix</option>
          </select>
        </div>
        <div class="custom-option">
          <label>Difficulty</label>
          <select id="difficultySelect">
            <option value="easy">Easy</option>
            <option value="normal" selected>Normal</option>
            <option value="hard">Hard</option>
            <option value="insane">Insane</option>
          </select>
        </div>
        <div class="custom-option">
          <label>Grid Size</label>
          <select id="gridSelect">
            <option value="20">Small (20x20)</option>
            <option value="25" selected>Medium (25x25)</option>
            <option value="30">Large (30x30)</option>
          </select>
        </div>
      </div>

      <div style="margin-top: 20px;">
        <p style="margin-bottom: 10px; opacity: 0.8;">High Score: <span id="highScoreDisplay">0</span></p>
        <button id="viewAchievements" style="margin-right: 10px;">üèÖ Achievements</button>
        <button id="viewStats" style="margin-right: 10px;">üìä Stats</button>
        <button id="resetProgress">üîÑ Reset Progress</button>
      </div>
    </div>
  </div>

  <!-- Game Container -->
  <div class="game-container hidden" id="gameContainer">
    <div class="game-header">
      <div class="stats">
        <div class="stat-item">
          <span class="stat-icon">üí∞</span>
          <span id="score">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-icon">‚≠ê</span>
          <span id="level">1</span>
        </div>
        <div class="stat-item">
          <span class="stat-icon">‚ù§Ô∏è</span>
          <span id="lives">3</span>
        </div>
        <div class="stat-item">
          <span class="stat-icon">üî•</span>
          <span id="combo">x1</span>
        </div>
      </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div class="controls">
      <button id="pauseBtn">‚è∏Ô∏è Pause</button>
      <button id="restartBtn">üîÑ Restart</button>
      <button id="menuBtn">üìã Menu</button>
      <button id="soundBtn">üîä Sound</button>
    </div>

    <div class="mobile-controls">
      <div></div>
      <button class="mobile-btn" data-dir="up">‚Üë</button>
      <div></div>
      <button class="mobile-btn" data-dir="left">‚Üê</button>
      <button class="mobile-btn" data-dir="down">‚Üì</button>
      <button class="mobile-btn" data-dir="right">‚Üí</button>
    </div>
  </div>

  <!-- Achievement Notifications -->
  <div class="achievements" id="achievements"></div>

  <script>
    // Game Configuration
    const CONFIG = {
      CELL_SIZE: 16,
      DEFAULT_GRID: 25,
      FPS: 60,
      POWER_UP_DURATION: 5000,
      COMBO_TIME: 2000,
      PARTICLE_COUNT: 8,
      ACHIEVEMENTS: [
        { id: 'first_food', name: 'First Bite', desc: 'Eat your first food', icon: 'üçé' },
        { id: 'speed_demon', name: 'Speed Demon', desc: 'Reach speed level 10', icon: '‚ö°' },
        { id: 'survivor', name: 'Survivor', desc: 'Survive for 5 minutes', icon: '‚è∞' },
        { id: 'combo_master', name: 'Combo Master', desc: 'Achieve a 10x combo', icon: 'üî•' },
        { id: 'level_10', name: 'Level Master', desc: 'Reach level 10', icon: 'üèÜ' },
        { id: 'score_1000', name: 'High Scorer', desc: 'Score 1000 points', icon: 'üíØ' },
        { id: 'perfect_level', name: 'Perfectionist', desc: 'Complete a level without hitting walls', icon: '‚ú®' },
        { id: 'power_collector', name: 'Power Collector', desc: 'Collect 20 power-ups', icon: 'üí™' },
        { id: 'snake_long', name: 'Python', desc: 'Grow snake to 50 segments', icon: 'üêç' },
        { id: 'challenge_complete', name: 'Challenge Champion', desc: 'Complete a challenge', icon: 'üéØ' }
      ]
    };

    // Sound Manager
    class SoundManager {
      constructor() {
        this.enabled = true;
        this.audioContext = null;
      }

      init() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.warn('Audio not supported');
        }
      }

      play(type) {
        if (!this.enabled || !this.audioContext) return;
        
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        osc.connect(gain);
        gain.connect(this.audioContext.destination);
        
        const now = this.audioContext.currentTime;
        
        switch(type) {
          case 'eat':
            osc.frequency.setValueAtTime(523, now);
            osc.frequency.exponentialRampToValueAtTime(784, now + 0.1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
            break;
          case 'powerup':
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(800, now + 0.2);
            gain.gain.setValueAtTime(0.4, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(now);
            osc.stop(now + 0.3);
            break;
          case 'hit':
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
            gain.gain.setValueAtTime(0.4, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
            break;
          case 'levelup':
            for (let i = 0; i < 3; i++) {
              const o = this.audioContext.createOscillator();
              const g = this.audioContext.createGain();
              o.connect(g);
              g.connect(this.audioContext.destination);
              o.frequency.setValueAtTime(523 * Math.pow(2, i/3), now + i * 0.1);
              g.gain.setValueAtTime(0.3, now + i * 0.1);
              g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.2);
              o.start(now + i * 0.1);
              o.stop(now + i * 0.1 + 0.2);
            }
            break;
        }
      }

      toggle() {
        this.enabled = !this.enabled;
        return this.enabled;
      }
    }

    // Particle System
    class ParticleSystem {
      constructor(container) {
        this.container = container;
      }

      emit(x, y, color, count = CONFIG.PARTICLE_COUNT) {
        for (let i = 0; i < count; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = x + 'px';
          particle.style.top = y + 'px';
          particle.style.width = '8px';
          particle.style.height = '8px';
          particle.style.background = color;
          particle.style.boxShadow = `0 0 10px ${color}`;
          
          const angle = (Math.PI * 2 / count) * i;
          const velocity = 2 + Math.random() * 3;
          particle.style.setProperty('--vx', Math.cos(angle) * velocity + 'px');
          particle.style.setProperty('--vy', Math.sin(angle) * velocity + 'px');
          
          this.container.appendChild(particle);
          setTimeout(() => particle.remove(), 1000);
        }
      }
    }

    // Main Game Class
    class SnakeGame {
      constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.sound = new SoundManager();
        this.particles = new ParticleSystem(document.querySelector('.game-container'));
        
        this.gridSize = CONFIG.DEFAULT_GRID;
        this.cellSize = CONFIG.CELL_SIZE;
        this.mode = 'classic';
        this.theme = 'neon';
        this.difficulty = 'normal';
        
        this.snake = [];
        this.direction = { x: 1, y: 0 };
        this.nextDirection = { x: 1, y: 0 };
        this.food = null;
        this.obstacles = [];
        this.powerUps = [];
        this.activePowerUp = null;
        this.powerUpTimer = 0;
        
        this.score = 0;
        this.level = 1;
        this.lives = 3;
        this.combo = 1;
        this.lastFoodTime = 0;
        
        this.gameState = 'menu';
        this.isPaused = false;
        this.gameTime = 0;
        this.frameCount = 0;
        this.moveTimer = 0;
        this.moveSpeed = 100;
        
        this.stats = this.loadStats();
        this.achievements = this.loadAchievements();
        this.highScore = this.stats.highScore || 0;
        
        this.challenges = [
          { name: 'Speed Run', desc: 'Eat 10 food in 30 seconds', target: 10, time: 30000 },
          { name: 'No Walls', desc: 'Survive without hitting walls for 60 seconds', time: 60000 },
          { name: 'Collector', desc: 'Collect 5 power-ups in one game', target: 5 }
        ];
        this.currentChallenge = null;
        this.challengeProgress = 0;
        
        this.init();
      }

      init() {
        this.setupCanvas();
        this.setupEventListeners();
        this.sound.init();
        this.showMenu();
      }

      setupCanvas() {
        this.canvas.width = this.gridSize * this.cellSize;
        this.canvas.height = this.gridSize * this.cellSize;
        this.ctx.imageSmoothingEnabled = false;
      }

      setupEventListeners() {
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
          if (this.gameState !== 'playing' || this.isPaused) return;
          
          switch(e.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
              if (this.direction.y === 0) {
                this.nextDirection = { x: 0, y: -1 };
              }
              break;
            case 'ArrowDown':
            case 's':
            case 'S':
              if (this.direction.y === 0) {
                this.nextDirection = { x: 0, y: 1 };
              }
              break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
              if (this.direction.x === 0) {
                this.nextDirection = { x: -1, y: 0 };
              }
              break;
            case 'ArrowRight':
            case 'd':
            case 'D':
              if (this.direction.x === 0) {
                this.nextDirection = { x: 1, y: 0 };
              }
              break;
            case ' ':
              this.togglePause();
              break;
          }
        });

        // Mobile controls
        document.querySelectorAll('.mobile-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const dir = btn.dataset.dir;
            switch(dir) {
              case 'up':
                if (this.direction.y === 0) this.nextDirection = { x: 0, y: -1 };
                break;
              case 'down':
                if (this.direction.y === 0) this.nextDirection = { x: 0, y: 1 };
                break;
              case 'left':
                if (this.direction.x === 0) this.nextDirection = { x: -1, y: 0 };
                break;
              case 'right':
                if (this.direction.x === 0) this.nextDirection = { x: 1, y: 0 };
                break;
            }
          });
        });

        // Menu controls
        document.querySelectorAll('.mode-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            this.mode = btn.dataset.mode;
            this.startGame();
          });
        });

        document.getElementById('themeSelect').addEventListener('change', (e) => {
          this.theme = e.target.value;
        });

        document.getElementById('difficultySelect').addEventListener('change', (e) => {
          this.difficulty = e.target.value;
          this.updateDifficulty();
        });

        document.getElementById('gridSelect').addEventListener('change', (e) => {
          this.gridSize = parseInt(e.target.value);
          this.setupCanvas();
        });

        // Game controls
        document.getElementById('pauseBtn')?.addEventListener('click', () => this.togglePause());
        document.getElementById('restartBtn')?.addEventListener('click', () => this.restart());
        document.getElementById('menuBtn')?.addEventListener('click', () => this.showMenu());
        document.getElementById('soundBtn')?.addEventListener('click', () => {
          const enabled = this.sound.toggle();
          document.getElementById('soundBtn').textContent = enabled ? 'üîä Sound' : 'üîá Sound';
        });

        // Menu buttons
        document.getElementById('viewAchievements')?.addEventListener('click', () => this.showAchievements());
        document.getElementById('viewStats')?.addEventListener('click', () => this.showStats());
        document.getElementById('resetProgress')?.addEventListener('click', () => {
          if (confirm('Reset all progress? This cannot be undone!')) {
            this.resetProgress();
          }
        });

        // Touch controls for swipe
        let touchStartX = 0;
        let touchStartY = 0;
        
        this.canvas.addEventListener('touchstart', (e) => {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        });

        this.canvas.addEventListener('touchend', (e) => {
          if (!touchStartX || !touchStartY) return;
          
          const touchEndX = e.changedTouches[0].clientX;
          const touchEndY = e.changedTouches[0].clientY;
          
          const dx = touchEndX - touchStartX;
          const dy = touchEndY - touchStartY;
          
          if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0 && this.direction.x === 0) {
              this.nextDirection = { x: 1, y: 0 };
            } else if (dx < 0 && this.direction.x === 0) {
              this.nextDirection = { x: -1, y: 0 };
            }
          } else {
            if (dy > 0 && this.direction.y === 0) {
              this.nextDirection = { x: 0, y: 1 };
            } else if (dy < 0 && this.direction.y === 0) {
              this.nextDirection = { x: 0, y: -1 };
            }
          }
        });
      }

      showMenu() {
        this.gameState = 'menu';
        document.getElementById('mainMenu').classList.remove('hidden');
        document.getElementById('gameContainer').classList.add('hidden');
        document.getElementById('highScoreDisplay').textContent = this.highScore;
      }

      startGame() {
        document.getElementById('mainMenu').classList.add('hidden');
        document.getElementById('gameContainer').classList.remove('hidden');
        
        this.gameState = 'playing';
        this.reset();
        
        if (this.mode === 'challenge') {
          this.currentChallenge = this.challenges[Math.floor(Math.random() * this.challenges.length)];
          this.challengeProgress = 0;
          this.showNotification(`Challenge: ${this.currentChallenge.name}`, this.currentChallenge.desc);
        }
        
        this.gameLoop();
      }

      reset() {
        const center = Math.floor(this.gridSize / 2);
        this.snake = [
          { x: center, y: center },
          { x: center - 1, y: center },
          { x: center - 2, y: center }
        ];
        this.direction = { x: 1, y: 0 };
        this.nextDirection = { x: 1, y: 0 };
        
        this.score = 0;
        this.level = 1;
        this.lives = this.mode === 'survival' ? 1 : 3;
        this.combo = 1;
        this.lastFoodTime = Date.now();
        
        this.obstacles = [];
        this.powerUps = [];
        this.activePowerUp = null;
        this.powerUpTimer = 0;
        
        this.gameTime = 0;
        this.frameCount = 0;
        this.moveTimer = 0;
        
        this.updateDifficulty();
        this.spawnFood();
        this.generateObstacles();
        
        this.updateUI();
      }

      updateDifficulty() {
        const speeds = {
          easy: 150,
          normal: 100,
          hard: 70,
          insane: 40
        };
        this.moveSpeed = speeds[this.difficulty] - (this.level - 1) * 5;
        this.moveSpeed = Math.max(this.moveSpeed, 20);
      }

      gameLoop(timestamp = 0) {
        if (this.gameState !== 'playing') return;
        
        const deltaTime = timestamp - this.lastTimestamp || 0;
        this.lastTimestamp = timestamp;
        
        if (!this.isPaused) {
          this.gameTime += deltaTime;
          this.moveTimer += deltaTime;
          
          if (this.moveTimer >= this.moveSpeed) {
            this.update();
            this.moveTimer = 0;
          }
          
          this.updatePowerUps(deltaTime);
          this.updateChallenge(deltaTime);
          this.frameCount++;
        }
        
        this.draw();
        requestAnimationFrame((t) => this.gameLoop(t));
      }

      update() {
        if (this.gameState !== 'playing' || this.isPaused) return;
        
        // Update direction
        this.direction = { ...this.nextDirection };
        
        // Calculate new head position
        const head = { ...this.snake[0] };
        head.x += this.direction.x;
        head.y += this.direction.y;
        
        // Handle active power-ups
        if (this.activePowerUp === 'ghost') {
          // Ghost mode - can pass through walls
          if (head.x < 0) head.x = this.gridSize - 1;
          if (head.x >= this.gridSize) head.x = 0;
          if (head.y < 0) head.y = this.gridSize - 1;
          if (head.y >= this.gridSize) head.y = 0;
        } else {
          // Check wall collision
          if (head.x < 0 || head.x >= this.gridSize || 
              head.y < 0 || head.y >= this.gridSize) {
            this.handleDeath();
            return;
          }
        }
        
        // Check self collision (unless invincible)
        if (this.activePowerUp !== 'invincible') {
          for (let segment of this.snake) {
            if (head.x === segment.x && head.y === segment.y) {
              this.handleDeath();
              return;
            }
          }
        }
        
        // Check obstacle collision
        if (this.activePowerUp !== 'invincible' && this.activePowerUp !== 'ghost') {
          for (let obstacle of this.obstacles) {
            if (head.x === obstacle.x && head.y === obstacle.y) {
              this.handleDeath();
              return;
            }
          }
        }
        
        // Move snake
        this.snake.unshift(head);
        
        // Check food collision
        if (head.x === this.food.x && head.y === this.food.y) {
          this.eatFood();
        } else {
          this.snake.pop();
        }
        
        // Check power-up collision
        for (let i = this.powerUps.length - 1; i >= 0; i--) {
          const powerUp = this.powerUps[i];
          if (head.x === powerUp.x && head.y === powerUp.y) {
            this.collectPowerUp(powerUp);
            this.powerUps.splice(i, 1);
          }
        }
        
        // Move obstacles in arcade/challenge modes
        if (this.mode === 'arcade' || this.mode === 'challenge') {
          this.updateObstacles();
        }
      }

      eatFood() {
        // Calculate score with combo
        const timeSinceLastFood = Date.now() - this.lastFoodTime;
        if (timeSinceLastFood < CONFIG.COMBO_TIME) {
          this.combo = Math.min(this.combo + 1, 10);
          this.showCombo();
        } else {
          this.combo = 1;
        }
        
        const points = 10 * this.level * this.combo;
        this.score += points;
        this.lastFoodTime = Date.now();
        
        // Sound and particles
        this.sound.play('eat');
        const rect = this.canvas.getBoundingClientRect();
        this.particles.emit(
          rect.left + this.food.x * this.cellSize + this.cellSize/2,
          rect.top + this.food.y * this.cellSize + this.cellSize/2,
          '#ffeb3b',
          6
        );
        
        // Check achievements
        if (this.stats.totalFood === 0) {
          this.unlockAchievement('first_food');
        }
        this.stats.totalFood++;
        
        if (this.snake.length >= 50) {
          this.unlockAchievement('snake_long');
        }
        
        // Level up
        if (this.score >= this.level * 100) {
          this.levelUp();
        }
        
        // Spawn new food and maybe power-up
        this.spawnFood();
        
        if (this.mode === 'arcade' && Math.random() < 0.2) {
          this.spawnPowerUp();
        }
        
        // Update challenge progress
        if (this.currentChallenge?.target) {
          this.challengeProgress++;
        }
        
        this.updateUI();
      }

      spawnFood() {
        const available = [];
        for (let x = 0; x < this.gridSize; x++) {
          for (let y = 0; y < this.gridSize; y++) {
            if (!this.isOccupied(x, y)) {
              available.push({ x, y });
            }
          }
        }
        
        if (available.length > 0) {
          this.food = available[Math.floor(Math.random() * available.length)];
        }
      }

      spawnPowerUp() {
        const types = ['speed', 'slow', 'ghost', 'invincible', 'double', 'shrink'];
        const available = [];
        
        for (let x = 0; x < this.gridSize; x++) {
          for (let y = 0; y < this.gridSize; y++) {
            if (!this.isOccupied(x, y)) {
              available.push({ x, y });
            }
          }
        }
        
        if (available.length > 0 && this.powerUps.length < 3) {
          const pos = available[Math.floor(Math.random() * available.length)];
          this.powerUps.push({
            x: pos.x,
            y: pos.y,
            type: types[Math.floor(Math.random() * types.length)],
            lifetime: 10000
          });
        }
      }

      collectPowerUp(powerUp) {
        this.sound.play('powerup');
        this.stats.powerUpsCollected++;
        
        if (this.stats.powerUpsCollected >= 20) {
          this.unlockAchievement('power_collector');
        }
        
        // Activate power-up
        this.activePowerUp = powerUp.type;
        this.powerUpTimer = CONFIG.POWER_UP_DURATION;
        
        // Show power-up indicator
        this.showPowerUp(powerUp.type);
        
        // Apply immediate effects
        switch (powerUp.type) {
          case 'double':
            this.score *= 2;
            break;
          case 'shrink':
            if (this.snake.length > 3) {
              this.snake = this.snake.slice(0, Math.floor(this.snake.length / 2));
            }
            break;
          case 'speed':
            this.moveSpeed *= 0.5;
            break;
          case 'slow':
            this.moveSpeed *= 2;
            break;
        }
        
        this.updateUI();
      }

      updatePowerUps(deltaTime) {
        // Update power-up lifetimes
        for (let i = this.powerUps.length - 1; i >= 0; i--) {
          this.powerUps[i].lifetime -= deltaTime;
          if (this.powerUps[i].lifetime <= 0) {
            this.powerUps.splice(i, 1);
          }
        }
        
        // Update active power-up timer
        if (this.powerUpTimer > 0) {
          this.powerUpTimer -= deltaTime;
          if (this.powerUpTimer <= 0) {
            // Deactivate power-up
            switch (this.activePowerUp) {
              case 'speed':
                this.moveSpeed *= 2;
                break;
              case 'slow':
                this.moveSpeed *= 0.5;
                break;
            }
            this.activePowerUp = null;
            document.querySelector('.power-up-indicator')?.remove();
          }
        }
      }

      generateObstacles() {
        this.obstacles = [];
        if (this.mode === 'classic') return;
        
        const count = Math.min(this.level * 2, 10);
        for (let i = 0; i < count; i++) {
          let pos;
          do {
            pos = {
              x: Math.floor(Math.random() * this.gridSize),
              y: Math.floor(Math.random() * this.gridSize)
            };
          } while (this.isOccupied(pos.x, pos.y));
          
          this.obstacles.push({
            x: pos.x,
            y: pos.y,
            type: Math.random() < 0.3 ? 'moving' : 'static',
            direction: Math.random() < 0.5 ? 1 : -1,
            axis: Math.random() < 0.5 ? 'x' : 'y'
          });
        }
      }

      updateObstacles() {
        for (let obstacle of this.obstacles) {
          if (obstacle.type === 'moving') {
            const oldPos = { x: obstacle.x, y: obstacle.y };
            
            if (obstacle.axis === 'x') {
              obstacle.x += obstacle.direction;
              if (obstacle.x < 0 || obstacle.x >= this.gridSize) {
                obstacle.direction *= -1;
                obstacle.x = oldPos.x;
              }
            } else {
              obstacle.y += obstacle.direction;
              if (obstacle.y < 0 || obstacle.y >= this.gridSize) {
                obstacle.direction *= -1;
                obstacle.y = oldPos.y;
              }
            }
            
            // Check if obstacle would hit snake
            for (let segment of this.snake) {
              if (obstacle.x === segment.x && obstacle.y === segment.y) {
                obstacle.x = oldPos.x;
                obstacle.y = oldPos.y;
                obstacle.direction *= -1;
              }
            }
          }
        }
      }

      isOccupied(x, y) {
        // Check snake
        for (let segment of this.snake) {
          if (segment.x === x && segment.y === y) return true;
        }
        
        // Check obstacles
        for (let obstacle of this.obstacles) {
          if (obstacle.x === x && obstacle.y === y) return true;
        }
        
        // Check food
        if (this.food && this.food.x === x && this.food.y === y) return true;
        
        // Check power-ups
        for (let powerUp of this.powerUps) {
          if (powerUp.x === x && powerUp.y === y) return true;
        }
        
        return false;
      }

      levelUp() {
        this.level++;
        this.sound.play('levelup');
        this.showNotification('Level Up!', `Welcome to Level ${this.level}`);
        
        if (this.level === 10) {
          this.unlockAchievement('level_10');
        }
        
        this.updateDifficulty();
        this.generateObstacles();
      }

      handleDeath() {
        this.lives--;
        this.sound.play('hit');
        
        if (this.lives <= 0) {
          this.gameOver();
        } else {
          // Reset position but keep score
          const center = Math.floor(this.gridSize / 2);
          this.snake = [
            { x: center, y: center },
            { x: center - 1, y: center },
            { x: center - 2, y: center }
          ];
          this.direction = { x: 1, y: 0 };
          this.nextDirection = { x: 1, y: 0 };
          this.showNotification('Ouch!', `${this.lives} lives remaining`);
        }
        
        this.updateUI();
      }

      gameOver() {
        this.gameState = 'gameover';
        
        // Update stats
        if (this.score > this.highScore) {
          this.highScore = this.score;
          this.stats.highScore = this.score;
          this.showNotification('New High Score!', `${this.score} points!`);
        }
        
        this.stats.gamesPlayed++;
        this.stats.totalScore += this.score;
        this.saveStats();
        
        // Check achievements
        if (this.score >= 1000) {
          this.unlockAchievement('score_1000');
        }
        
        if (this.gameTime >= 300000) {
          this.unlockAchievement('survivor');
        }
        
        // Show game over screen
        setTimeout(() => {
          if (confirm(`Game Over!\n\nScore: ${this.score}\nLevel: ${this.level}\n\nPlay again?`)) {
            this.restart();
          } else {
            this.showMenu();
          }
        }, 100);
      }

      restart() {
        this.gameState = 'playing';
        this.reset();
        this.gameLoop();
      }

      togglePause() {
        if (this.gameState !== 'playing') return;
        this.isPaused = !this.isPaused;
        document.getElementById('pauseBtn').textContent = this.isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
      }

      updateChallenge(deltaTime) {
        if (!this.currentChallenge) return;
        
        if (this.currentChallenge.time) {
          this.currentChallenge.time -= deltaTime;
          if (this.currentChallenge.time <= 0) {
            if (this.currentChallenge.target) {
              if (this.challengeProgress >= this.currentChallenge.target) {
                this.completeChallenge();
              } else {
                this.failChallenge();
              }
            } else {
              this.completeChallenge();
            }
          }
        }
        
        if (this.currentChallenge.target && this.challengeProgress >= this.currentChallenge.target) {
          this.completeChallenge();
        }
      }

      completeChallenge() {
        this.score += 500;
        this.showNotification('Challenge Complete!', '+500 points!');
        this.unlockAchievement('challenge_complete');
        this.currentChallenge = null;
      }

      failChallenge() {
        this.showNotification('Challenge Failed', 'Better luck next time!');
        this.currentChallenge = null;
      }

      draw() {
        // Clear canvas
        this.ctx.fillStyle = '#111';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw grid
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        this.ctx.lineWidth = 1;
        for (let i = 0; i <= this.gridSize; i++) {
          this.ctx.beginPath();
          this.ctx.moveTo(i * this.cellSize, 0);
          this.ctx.lineTo(i * this.cellSize, this.canvas.height);
          this.ctx.stroke();
          
          this.ctx.beginPath();
          this.ctx.moveTo(0, i * this.cellSize);
          this.ctx.lineTo(this.canvas.width, i * this.cellSize);
          this.ctx.stroke();
        }
        
        // Draw obstacles
        for (let obstacle of this.obstacles) {
          this.ctx.fillStyle = obstacle.type === 'moving' ? '#ff6b6b' : '#ff9999';
          this.ctx.fillRect(
            obstacle.x * this.cellSize + 2,
            obstacle.y * this.cellSize + 2,
            this.cellSize - 4,
            this.cellSize - 4
          );
        }
        
        // Draw food
        if (this.food) {
          this.ctx.fillStyle = '#ff0000';
          this.ctx.beginPath();
          this.ctx.arc(
            this.food.x * this.cellSize + this.cellSize / 2,
            this.food.y * this.cellSize + this.cellSize / 2,
            this.cellSize / 2 - 2,
            0,
            Math.PI * 2
          );
          this.ctx.fill();
        }
        
        // Draw power-ups
        for (let powerUp of this.powerUps) {
          const colors = {
            speed: '#00ff00',
            slow: '#0000ff',
            ghost: '#ffffff',
            invincible: '#ffd700',
            double: '#ff00ff',
            shrink: '#00ffff'
          };
          
          this.ctx.fillStyle = colors[powerUp.type];
          this.ctx.fillRect(
            powerUp.x * this.cellSize + 1,
            powerUp.y * this.cellSize + 1,
            this.cellSize - 2,
            this.cellSize - 2
          );
          
          // Draw power-up symbol
          this.ctx.fillStyle = '#000';
          this.ctx.font = '12px Arial';
          this.ctx.textAlign = 'center';
          this.ctx.textBaseline = 'middle';
          const symbols = {
            speed: '‚ö°',
            slow: 'üêå',
            ghost: 'üëª',
            invincible: 'üõ°Ô∏è',
            double: '2x',
            shrink: 'üìâ'
          };
          this.ctx.fillText(
            symbols[powerUp.type],
            powerUp.x * this.cellSize + this.cellSize / 2,
            powerUp.y * this.cellSize + this.cellSize / 2
          );
        }
        
        // Draw snake
        this.drawSnake();
        
        // Draw pause overlay
        if (this.isPaused) {
          this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          
          this.ctx.fillStyle = '#fff';
          this.ctx.font = 'bold 32px Arial';
          this.ctx.textAlign = 'center';
          this.ctx.textBaseline = 'middle';
          this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);
        }
      }

      drawSnake() {
        const themes = {
          neon: {
            head: '#00ff00',
            body: '#00cc00',
            glow: 'rgba(0, 255, 0, 0.5)'
          },
          classic: {
            head: '#4CAF50',
            body: '#388E3C',
            glow: null
          },
          rainbow: {
            head: null,
            body: null,
            glow: 'rgba(255, 255, 255, 0.3)'
          },
          fire: {
            head: '#ff6600',
            body: '#ff3300',
            glow: 'rgba(255, 100, 0, 0.5)'
          },
          ice: {
            head: '#00ffff',
            body: '#0099ff',
            glow: 'rgba(0, 200, 255, 0.5)'
          },
          matrix: {
            head: '#00ff00',
            body: '#008800',
            glow: 'rgba(0, 255, 0, 0.3)'
          }
        };
        
        const theme = themes[this.theme];
        
        for (let i = 0; i < this.snake.length; i++) {
          const segment = this.snake[i];
          
          if (this.theme === 'rainbow') {
            const hue = (this.frameCount * 2 + i * 10) % 360;
            this.ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
          } else {
            this.ctx.fillStyle = i === 0 ? theme.head : theme.body;
          }
          
          // Add glow effect
          if (theme.glow) {
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = theme.glow;
          }
          
          // Draw segment
          if (this.activePowerUp === 'ghost') {
            this.ctx.globalAlpha = 0.5;
          }
          
          this.ctx.fillRect(
            segment.x * this.cellSize + 1,
            segment.y * this.cellSize + 1,
            this.cellSize - 2,
            this.cellSize - 2
          );
          
          // Reset effects
          this.ctx.globalAlpha = 1;
          this.ctx.shadowBlur = 0;
          
          // Draw eyes on head
          if (i === 0) {
            this.ctx.fillStyle = '#fff';
            const eyeSize = 3;
            const eyeOffset = 4;
            
            if (this.direction.x === 1) {
              this.ctx.fillRect(
                segment.x * this.cellSize + this.cellSize - eyeOffset,
                segment.y * this.cellSize + eyeOffset,
                eyeSize, eyeSize
              );
              this.ctx.fillRect(
                segment.x * this.cellSize + this.cellSize - eyeOffset,
                segment.y * this.cellSize + this.cellSize - eyeOffset - eyeSize,
                eyeSize, eyeSize
              );
            } else if (this.direction.x === -1) {
              this.ctx.fillRect(
                segment.x * this.cellSize + eyeOffset - eyeSize,
                segment.y * this.cellSize + eyeOffset,
                eyeSize, eyeSize
              );
              this.ctx.fillRect(
                segment.x * this.cellSize + eyeOffset - eyeSize,
                segment.y * this.cellSize + this.cellSize - eyeOffset - eyeSize,
                eyeSize, eyeSize
              );
            } else if (this.direction.y === 1) {
              this.ctx.fillRect(
                segment.x * this.cellSize + eyeOffset,
                segment.y * this.cellSize + this.cellSize - eyeOffset,
                eyeSize, eyeSize
              );
              this.ctx.fillRect(
                segment.x * this.cellSize + this.cellSize - eyeOffset - eyeSize,
                segment.y * this.cellSize + this.cellSize - eyeOffset,
                eyeSize, eyeSize
              );
            } else if (this.direction.y === -1) {
              this.ctx.fillRect(
                segment.x * this.cellSize + eyeOffset,
                segment.y * this.cellSize + eyeOffset - eyeSize,
                eyeSize, eyeSize
              );
              this.ctx.fillRect(
                segment.x * this.cellSize + this.cellSize - eyeOffset - eyeSize,
                segment.y * this.cellSize + eyeOffset - eyeSize,
                eyeSize, eyeSize
              );
            }
          }
        }
      }

      updateUI() {
        document.getElementById('score').textContent = this.score;
        document.getElementById('level').textContent = this.level;
        document.getElementById('lives').textContent = this.lives;
        document.getElementById('combo').textContent = `x${this.combo}`;
      }

      showNotification(title, message) {
        const notification = document.createElement('div');
        notification.className = 'achievement-popup';
        notification.innerHTML = `<strong>${title}</strong><br>${message}`;
        document.getElementById('achievements').appendChild(notification);
        
        setTimeout(() => notification.remove(), 3500);
      }

      showCombo() {
        const existing = document.querySelector('.combo-display');
        if (existing) existing.remove();
        
        const combo = document.createElement('div');
        combo.className = 'combo-display';
        combo.textContent = `${this.combo}x COMBO!`;
        document.querySelector('.game-container').appendChild(combo);
        
        setTimeout(() => combo.remove(), 1000);
      }

      showPowerUp(type) {
        const existing = document.querySelector('.power-up-indicator');
        if (existing) existing.remove();
        
        const names = {
          speed: '‚ö° SPEED BOOST',
          slow: 'üêå SLOW MOTION',
          ghost: 'üëª GHOST MODE',
          invincible: 'üõ°Ô∏è INVINCIBLE',
          double: 'üí∞ DOUBLE POINTS',
          shrink: 'üìâ SHRINK'
        };
        
        const indicator = document.createElement('div');
        indicator.className = 'power-up-indicator';
        indicator.textContent = names[type];
        document.querySelector('.game-container').appendChild(indicator);
      }

      unlockAchievement(id) {
        if (this.achievements[id]) return;
        
        this.achievements[id] = true;
        this.saveAchievements();
        
        const achievement = CONFIG.ACHIEVEMENTS.find(a => a.id === id);
        if (achievement) {
          this.showNotification(`${achievement.icon} Achievement Unlocked!`, achievement.name);
        }
      }

      showAchievements() {
        const unlocked = Object.keys(this.achievements).length;
        const total = CONFIG.ACHIEVEMENTS.length;
        
        let message = `Achievements: ${unlocked}/${total}\n\n`;
        
        CONFIG.ACHIEVEMENTS.forEach(achievement => {
          const status = this.achievements[achievement.id] ? '‚úÖ' : '‚ùå';
          message += `${status} ${achievement.icon} ${achievement.name}\n   ${achievement.desc}\n\n`;
        });
        
        alert(message);
      }

      showStats() {
        const stats = `
Statistics:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üèÜ High Score: ${this.stats.highScore || 0}
üéÆ Games Played: ${this.stats.gamesPlayed || 0}
üí∞ Total Score: ${this.stats.totalScore || 0}
üçé Food Eaten: ${this.stats.totalFood || 0}
üí™ Power-ups: ${this.stats.powerUpsCollected || 0}
‚è±Ô∏è Time Played: ${Math.floor((this.stats.timePlayed || 0) / 60000)}m

Average Score: ${this.stats.gamesPlayed ? Math.floor(this.stats.totalScore / this.stats.gamesPlayed) : 0}
        `;
        
        alert(stats);
      }

      saveStats() {
        this.stats.timePlayed = (this.stats.timePlayed || 0) + this.gameTime;
        localStorage.setItem('snakeStats', JSON.stringify(this.stats));
      }

      loadStats() {
        const saved = localStorage.getItem('snakeStats');
        return saved ? JSON.parse(saved) : {
          highScore: 0,
          gamesPlayed: 0,
          totalScore: 0,
          totalFood: 0,
          powerUpsCollected: 0,
          timePlayed: 0
        };
      }

      saveAchievements() {
        localStorage.setItem('snakeAchievements', JSON.stringify(this.achievements));
      }

      loadAchievements() {
        const saved = localStorage.getItem('snakeAchievements');
        return saved ? JSON.parse(saved) : {};
      }

      resetProgress() {
        localStorage.removeItem('snakeStats');
        localStorage.removeItem('snakeAchievements');
        this.stats = this.loadStats();
        this.achievements = this.loadAchievements();
        this.highScore = 0;
        document.getElementById('highScoreDisplay').textContent = '0';
        alert('All progress has been reset!');
      }
    }

    // Initialize game
    const game = new SnakeGame();
  </script>
</body>
</html>